//프로그래머스 가장 가까운 같은 글자
function solution(s) {
    var answer = [-1];
    for(let i=1; i<s.length; i++){
        //탐색지점의 앞부터 맨앞까지를 잘라서 뒤집은뒤 indexOf()를 쓰면 나오는
        //제일 첫번째 탐색결과의 idx+1이 정답일것이다.
        let standard = [...s.slice(0,i)].reverse().join('');
        if(standard.indexOf(s[i]) === -1){
            answer.push(-1);
        }else{
            answer.push(standard.indexOf(s[i])+1);
        }
    }
    return answer;
}

//한번에 풀지못해 난항을 겪었던 문제, 처음에는 2중 for문으로 j변수를 두어 i-1 에서 감소시켜나가며 탐색을 시작했다
//flag 변수도 설정하여 발견여부도 체크했으나 변수가 난잡해지고 복잡해진 나머지 정확성 검사에서 틀린결과를 고치기가 어려워
//코드를 뒤엎고 생각하였다, i지점의 앞에까지를 잘라내어 뒤집은뒤 indexOf를 사용하여 s의 i인덱스값을 탐색하면 그게바로
//가장 가까운 같은 글자를 찾아주지 않을까. 하는 생각이었고 탐색된 결과에서 +1을 더해주어야 몇칸앞인지 정확한 값이 나오게되었다.
//틀린풀이에서 스스로가 코드를 갈아엎고 해결방안을 생각해 내서 풀어냈다는 점에서 다시한번 성장했음을 느낀다.