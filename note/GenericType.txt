public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(Status.SUCCESS, data, "요청이 성공적으로 처리되었습니다");
    }


public static ApiResponse<?> successWithNoContent() {
    return new ApiResponse<>(Status.SUCCESS, null, "요청이 성공적으로 처리되었지만 내용이 없습니다");
}

<T> 와 <?>를 왜 분리하여 사용했는가

> <T>는 호출시 구체적인 타입을 지정할 수 있게 해줍니다, 메서드 호출시 전달하는 data의 타입에 따라 T가 결정되며, 
호출하는 쪽에서는 데이터를 특정 타입으로 안전하게 받을 수 있어서 타입 안전성을 보장할 수 있습니다.

<?>는 와일드 카드 타입이라는 의미입니다. 이것은 특정 타입을 지정하지 않겠다는 의미로, successWithNoContent()는 
반환할 내용이 없으므로 타입을 명시적으로 설정할 필요가 없습니다.

추가)
<T> ApiResponse<T>의 앞의 <T>가 붙은 이유는 메서드에 선언된 제네릭 타입 매개변수를 의미. 이렇게 하면 메서드 내에서 제네릭 타입 T를 사용가능.

그래서 success(T data) 이렇게 메서드 내에서 T를 사용했던거 같습니다.

gpt 내용
이 경우에, 메서드의 리턴 타입은 ApiResponse<T>이고, 앞의 <T>는 이 메서드에서 사용할 제네릭 타입 T를 선언하는 것입니다. 이 선언을 통해 success 메서드는 호출될 때 전달된 data의 타입을 기준으로 T 타입을 추론할 수 있게 됩니다.

왜 메서드에 <T>를 붙였는가?
메서드의 제네릭 타입을 선언하는 이유는 이 메서드가 호출될 때마다 타입을 동적으로 지정할 수 있도록 하기 위해서입니다. 만약 <T> 없이 ApiResponse<T>만을 리턴 타입으로 선언하면, 클래스에 이미 제네릭 타입 T가 선언되어 있어야만 합니다. 그렇지 않으면 컴파일 에러가 발생하게 됩니다.

따라서 메서드에서 사용할 제네릭 타입 T를 선언하기 위해 <T>가 필요하고, 이는 메서드에 종속된 제네릭 타입을 의미합니다.
